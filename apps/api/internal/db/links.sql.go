// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: links.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTagToLink = `-- name: AddTagToLink :exec
INSERT INTO link_tags (link_id, tag_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddTagToLinkParams struct {
	LinkID pgtype.UUID
	TagID  int32
}

func (q *Queries) AddTagToLink(ctx context.Context, arg AddTagToLinkParams) error {
	_, err := q.db.Exec(ctx, addTagToLink, arg.LinkID, arg.TagID)
	return err
}

const countLinks = `-- name: CountLinks :one
SELECT COUNT(*)
FROM links l
WHERE l.user_id = $1
  AND (
    COALESCE($2::boolean, l.favorite) = l.favorite
  )
  AND (
    $3 IS NULL
    OR l.search_tsv @@ plainto_tsquery('english', $3::text)
    OR l.url ILIKE '%' || $3::text || '%'
  )
  AND (
    $4 IS NULL
    OR NOT EXISTS (
        SELECT 1
        FROM unnest($4::int4[]) AS tag_id
        WHERE NOT EXISTS (
            SELECT 1
            FROM link_tags lt
            WHERE lt.link_id = l.id
              AND lt.tag_id = tag_id
        )
    )
  )
`

type CountLinksParams struct {
	UserID   pgtype.UUID
	Favorite pgtype.Bool
	Query    interface{}
	TagIds   interface{}
}

func (q *Queries) CountLinks(ctx context.Context, arg CountLinksParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLinks,
		arg.UserID,
		arg.Favorite,
		arg.Query,
		arg.TagIds,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createHighlight = `-- name: CreateHighlight :one
INSERT INTO highlights (
    id,
    link_id,
    quote,
    annotation
)
VALUES (
    COALESCE($1, gen_random_uuid()),
    $2,
    $3,
    $4
)
RETURNING id, link_id, quote, annotation, created_at, updated_at
`

type CreateHighlightParams struct {
	ID     interface{}
	LinkID pgtype.UUID
	Text   string
	Note   pgtype.Text
}

func (q *Queries) CreateHighlight(ctx context.Context, arg CreateHighlightParams) (Highlight, error) {
	row := q.db.QueryRow(ctx, createHighlight,
		arg.ID,
		arg.LinkID,
		arg.Text,
		arg.Note,
	)
	var i Highlight
	err := row.Scan(
		&i.ID,
		&i.LinkID,
		&i.Quote,
		&i.Annotation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLink = `-- name: CreateLink :one
INSERT INTO links (
    id,
    user_id,
    url,
    title,
    favorite
) VALUES (
    $1,
    $2,
    $3,
    $4,
    COALESCE($5, FALSE)
)
RETURNING id, user_id, url, title, created_at, read_at, favorite
`

type CreateLinkParams struct {
	ID       pgtype.UUID
	UserID   pgtype.UUID
	Url      string
	Title    pgtype.Text
	Favorite interface{}
}

type CreateLinkRow struct {
	ID        pgtype.UUID
	UserID    pgtype.UUID
	Url       string
	Title     pgtype.Text
	CreatedAt pgtype.Timestamptz
	ReadAt    pgtype.Timestamptz
	Favorite  bool
}

func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (CreateLinkRow, error) {
	row := q.db.QueryRow(ctx, createLink,
		arg.ID,
		arg.UserID,
		arg.Url,
		arg.Title,
		arg.Favorite,
	)
	var i CreateLinkRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.CreatedAt,
		&i.ReadAt,
		&i.Favorite,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (name)
VALUES ($1)
RETURNING id, name
`

func (q *Queries) CreateTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deleteHighlight = `-- name: DeleteHighlight :exec
DELETE FROM highlights
WHERE id = $1
`

func (q *Queries) DeleteHighlight(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteHighlight, id)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const getLink = `-- name: GetLink :one
SELECT l.id,
       l.user_id,
       l.url,
       l.title,
       l.created_at,
       l.read_at,
       l.favorite
FROM links l
WHERE l.id = $1
`

type GetLinkRow struct {
	ID        pgtype.UUID
	UserID    pgtype.UUID
	Url       string
	Title     pgtype.Text
	CreatedAt pgtype.Timestamptz
	ReadAt    pgtype.Timestamptz
	Favorite  bool
}

func (q *Queries) GetLink(ctx context.Context, id pgtype.UUID) (GetLinkRow, error) {
	row := q.db.QueryRow(ctx, getLink, id)
	var i GetLinkRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.CreatedAt,
		&i.ReadAt,
		&i.Favorite,
	)
	return i, err
}

const getTag = `-- name: GetTag :one
SELECT id, name
FROM tags
WHERE id = $1
`

func (q *Queries) GetTag(ctx context.Context, id int32) (Tag, error) {
	row := q.db.QueryRow(ctx, getTag, id)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name
FROM tags
WHERE name = $1
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const listHighlightsByLink = `-- name: ListHighlightsByLink :many
SELECT id, link_id, quote, annotation, created_at, updated_at
FROM highlights
WHERE link_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListHighlightsByLink(ctx context.Context, linkID pgtype.UUID) ([]Highlight, error) {
	rows, err := q.db.Query(ctx, listHighlightsByLink, linkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Highlight
	for rows.Next() {
		var i Highlight
		if err := rows.Scan(
			&i.ID,
			&i.LinkID,
			&i.Quote,
			&i.Annotation,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinks = `-- name: ListLinks :many
SELECT l.id,
       l.user_id,
       l.url,
       l.title,
       l.source_domain,
       l.created_at,
       l.read_at,
       l.favorite,
       COALESCE(a.title, '') AS archive_title,
       COALESCE(a.byline, '') AS archive_byline,
       COALESCE(a.lang, '') AS lang,
       COALESCE(a.word_count, 0) AS word_count,
       COALESCE(a.extracted_text, '') AS extracted_text,
       COALESCE(tag_data.tag_ids, '{}'::INTEGER[]) AS tag_ids,
       COALESCE(tag_data.tag_names, '{}'::TEXT[]) AS tag_names,
       COALESCE(highlight_data.highlights, '[]'::JSON)::text AS highlights
FROM links l
LEFT JOIN archives a ON a.link_id = l.id
LEFT JOIN LATERAL (
    SELECT ARRAY_AGG(t.id ORDER BY t.name) AS tag_ids,
           ARRAY_AGG(t.name ORDER BY t.name) AS tag_names
    FROM link_tags lt
    JOIN tags t ON t.id = lt.tag_id
    WHERE lt.link_id = l.id
) AS tag_data ON TRUE
LEFT JOIN LATERAL (
    SELECT json_agg(
               json_build_object(
                   'id', h.id,
                   'link_id', h.link_id,
                  'text', h.quote,
                  'note', h.annotation,
                   'created_at', h.created_at,
                   'updated_at', h.updated_at
               )
               ORDER BY h.created_at DESC
           ) AS highlights
    FROM highlights h
    WHERE h.link_id = l.id
) AS highlight_data ON TRUE
WHERE l.user_id = $1
  AND (
    COALESCE($2::boolean, l.favorite) = l.favorite
  )
  AND (
    $3 IS NULL
    OR l.search_tsv @@ plainto_tsquery('english', $3::text)
    OR l.url ILIKE '%' || $3::text || '%'
  )
  AND (
    $4 IS NULL
    OR NOT EXISTS (
        SELECT 1
        FROM unnest($4::int4[]) AS tag_id
        WHERE NOT EXISTS (
            SELECT 1
            FROM link_tags lt
            WHERE lt.link_id = l.id
              AND lt.tag_id = tag_id
        )
    )
  )
ORDER BY l.created_at DESC
LIMIT $6
OFFSET $5
`

type ListLinksParams struct {
	UserID     pgtype.UUID
	Favorite   pgtype.Bool
	Query      interface{}
	TagIds     interface{}
	PageOffset int32
	PageLimit  int32
}

type ListLinksRow struct {
	ID            pgtype.UUID
	UserID        pgtype.UUID
	Url           string
	Title         pgtype.Text
	SourceDomain  pgtype.Text
	CreatedAt     pgtype.Timestamptz
	ReadAt        pgtype.Timestamptz
	Favorite      bool
	ArchiveTitle  string
	ArchiveByline string
	Lang          string
	WordCount     int32
	ExtractedText string
	TagIds        interface{}
	TagNames      interface{}
	Highlights    string
}

func (q *Queries) ListLinks(ctx context.Context, arg ListLinksParams) ([]ListLinksRow, error) {
	rows, err := q.db.Query(ctx, listLinks,
		arg.UserID,
		arg.Favorite,
		arg.Query,
		arg.TagIds,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLinksRow
	for rows.Next() {
		var i ListLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Title,
			&i.SourceDomain,
			&i.CreatedAt,
			&i.ReadAt,
			&i.Favorite,
			&i.ArchiveTitle,
			&i.ArchiveByline,
			&i.Lang,
			&i.WordCount,
			&i.ExtractedText,
			&i.TagIds,
			&i.TagNames,
			&i.Highlights,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagLinkCounts = `-- name: ListTagLinkCounts :many
SELECT t.id,
       t.name,
       COUNT(lt.link_id)::INT AS link_count
FROM tags t
LEFT JOIN link_tags lt ON lt.tag_id = t.id
GROUP BY t.id, t.name
ORDER BY t.name
`

type ListTagLinkCountsRow struct {
	ID        int32
	Name      string
	LinkCount int32
}

func (q *Queries) ListTagLinkCounts(ctx context.Context) ([]ListTagLinkCountsRow, error) {
	rows, err := q.db.Query(ctx, listTagLinkCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTagLinkCountsRow
	for rows.Next() {
		var i ListTagLinkCountsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.LinkCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name
FROM tags
ORDER BY name
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsForLink = `-- name: ListTagsForLink :many
SELECT t.id, t.name
FROM tags t
JOIN link_tags lt ON lt.tag_id = t.id
WHERE lt.link_id = $1
ORDER BY t.name
`

func (q *Queries) ListTagsForLink(ctx context.Context, linkID pgtype.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listTagsForLink, linkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTagFromLink = `-- name: RemoveTagFromLink :exec
DELETE FROM link_tags
WHERE link_id = $1
  AND tag_id = $2
`

type RemoveTagFromLinkParams struct {
	LinkID pgtype.UUID
	TagID  int32
}

func (q *Queries) RemoveTagFromLink(ctx context.Context, arg RemoveTagFromLinkParams) error {
	_, err := q.db.Exec(ctx, removeTagFromLink, arg.LinkID, arg.TagID)
	return err
}

const updateHighlight = `-- name: UpdateHighlight :one
UPDATE highlights
SET quote = $1,
    annotation = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING id, link_id, quote, annotation, created_at, updated_at
`

type UpdateHighlightParams struct {
	Text string
	Note pgtype.Text
	ID   pgtype.UUID
}

func (q *Queries) UpdateHighlight(ctx context.Context, arg UpdateHighlightParams) (Highlight, error) {
	row := q.db.QueryRow(ctx, updateHighlight, arg.Text, arg.Note, arg.ID)
	var i Highlight
	err := row.Scan(
		&i.ID,
		&i.LinkID,
		&i.Quote,
		&i.Annotation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLinkFavorite = `-- name: UpdateLinkFavorite :one
WITH updated AS (
    UPDATE links AS l
    SET favorite = $1
    WHERE l.id = $2
    RETURNING l.id,
              l.user_id,
              l.url,
              l.title,
              l.source_domain,
              l.created_at,
              l.read_at,
              l.favorite
)
SELECT u.id,
       u.user_id,
       u.url,
       u.title,
       u.source_domain,
       u.created_at,
       u.read_at,
       u.favorite,
       COALESCE(a.title, '') AS archive_title,
       COALESCE(a.byline, '') AS archive_byline,
       COALESCE(a.lang, '') AS lang,
       COALESCE(a.word_count, 0) AS word_count,
       COALESCE(a.extracted_text, '') AS extracted_text,
       COALESCE(tag_data.tag_ids, '{}'::INTEGER[]) AS tag_ids,
       COALESCE(tag_data.tag_names, '{}'::TEXT[]) AS tag_names,
       COALESCE(highlight_data.highlights, '[]'::JSON)::text AS highlights
FROM updated u
LEFT JOIN archives a ON a.link_id = u.id
LEFT JOIN LATERAL (
    SELECT ARRAY_AGG(t.id ORDER BY t.name) AS tag_ids,
           ARRAY_AGG(t.name ORDER BY t.name) AS tag_names
    FROM link_tags lt
    JOIN tags t ON t.id = lt.tag_id
    WHERE lt.link_id = u.id
) AS tag_data ON TRUE
LEFT JOIN LATERAL (
    SELECT json_agg(
               json_build_object(
                   'id', h.id,
                   'link_id', h.link_id,
                   'text', h.quote,
                   'note', h.annotation,
                   'created_at', h.created_at,
                   'updated_at', h.updated_at
               )
               ORDER BY h.created_at DESC
           ) AS highlights
    FROM highlights h
    WHERE h.link_id = u.id
) AS highlight_data ON TRUE
`

type UpdateLinkFavoriteParams struct {
	Favorite bool
	ID       pgtype.UUID
}

type UpdateLinkFavoriteRow struct {
	ID            pgtype.UUID
	UserID        pgtype.UUID
	Url           string
	Title         pgtype.Text
	SourceDomain  pgtype.Text
	CreatedAt     pgtype.Timestamptz
	ReadAt        pgtype.Timestamptz
	Favorite      bool
	ArchiveTitle  string
	ArchiveByline string
	Lang          string
	WordCount     int32
	ExtractedText string
	TagIds        interface{}
	TagNames      interface{}
	Highlights    string
}

func (q *Queries) UpdateLinkFavorite(ctx context.Context, arg UpdateLinkFavoriteParams) (UpdateLinkFavoriteRow, error) {
	row := q.db.QueryRow(ctx, updateLinkFavorite, arg.Favorite, arg.ID)
	var i UpdateLinkFavoriteRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.SourceDomain,
		&i.CreatedAt,
		&i.ReadAt,
		&i.Favorite,
		&i.ArchiveTitle,
		&i.ArchiveByline,
		&i.Lang,
		&i.WordCount,
		&i.ExtractedText,
		&i.TagIds,
		&i.TagNames,
		&i.Highlights,
	)
	return i, err
}

const updateLinkSourceDomain = `-- name: UpdateLinkSourceDomain :exec
UPDATE links
SET source_domain = $1
WHERE id = $2
`

type UpdateLinkSourceDomainParams struct {
	SourceDomain pgtype.Text
	ID           pgtype.UUID
}

func (q *Queries) UpdateLinkSourceDomain(ctx context.Context, arg UpdateLinkSourceDomainParams) error {
	_, err := q.db.Exec(ctx, updateLinkSourceDomain, arg.SourceDomain, arg.ID)
	return err
}

const updateLinkTitle = `-- name: UpdateLinkTitle :exec
UPDATE links
SET title = $1
WHERE id = $2
`

type UpdateLinkTitleParams struct {
	Title pgtype.Text
	ID    pgtype.UUID
}

func (q *Queries) UpdateLinkTitle(ctx context.Context, arg UpdateLinkTitleParams) error {
	_, err := q.db.Exec(ctx, updateLinkTitle, arg.Title, arg.ID)
	return err
}

const upsertArchive = `-- name: UpsertArchive :exec
INSERT INTO archives (
    link_id,
    html,
    extracted_text,
    word_count,
    lang,
    title,
    byline
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
ON CONFLICT (link_id) DO UPDATE
SET html = EXCLUDED.html,
    extracted_text = EXCLUDED.extracted_text,
    word_count = EXCLUDED.word_count,
    lang = EXCLUDED.lang,
    title = EXCLUDED.title,
    byline = EXCLUDED.byline
`

type UpsertArchiveParams struct {
	LinkID        pgtype.UUID
	Html          pgtype.Text
	ExtractedText pgtype.Text
	WordCount     pgtype.Int4
	Lang          pgtype.Text
	Title         pgtype.Text
	Byline        pgtype.Text
}

func (q *Queries) UpsertArchive(ctx context.Context, arg UpsertArchiveParams) error {
	_, err := q.db.Exec(ctx, upsertArchive,
		arg.LinkID,
		arg.Html,
		arg.ExtractedText,
		arg.WordCount,
		arg.Lang,
		arg.Title,
		arg.Byline,
	)
	return err
}
