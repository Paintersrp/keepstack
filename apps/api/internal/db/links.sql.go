// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: links.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLinks = `-- name: CountLinks :one
SELECT COUNT(*)
FROM links l
WHERE l.user_id = $1
  AND (
    $2 IS NULL OR l.favorite = $2
  )
  AND (
    $3 IS NULL
    OR l.search_tsv @@ plainto_tsquery('english', $3)
    OR l.url ILIKE '%' || $3 || '%'
  )
`

type CountLinksParams struct {
	UserID   pgtype.UUID
	Favorite interface{}
	Query    interface{}
}

func (q *Queries) CountLinks(ctx context.Context, arg CountLinksParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLinks, arg.UserID, arg.Favorite, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLink = `-- name: CreateLink :one
INSERT INTO links (
    id,
    user_id,
    url,
    title,
    favorite
) VALUES (
    $1,
    $2,
    $3,
    $4,
    COALESCE($5, FALSE)
)
RETURNING id, user_id, url, title, created_at, read_at, favorite
`

type CreateLinkParams struct {
	ID       pgtype.UUID
	UserID   pgtype.UUID
	Url      string
	Title    pgtype.Text
	Favorite interface{}
}

type CreateLinkRow struct {
	ID        pgtype.UUID
	UserID    pgtype.UUID
	Url       string
	Title     pgtype.Text
	CreatedAt pgtype.Timestamptz
	ReadAt    pgtype.Timestamptz
	Favorite  bool
}

func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (CreateLinkRow, error) {
	row := q.db.QueryRow(ctx, createLink,
		arg.ID,
		arg.UserID,
		arg.Url,
		arg.Title,
		arg.Favorite,
	)
	var i CreateLinkRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.CreatedAt,
		&i.ReadAt,
		&i.Favorite,
	)
	return i, err
}

const getLink = `-- name: GetLink :one
SELECT l.id,
       l.user_id,
       l.url,
       l.title,
       l.created_at,
       l.read_at,
       l.favorite
FROM links l
WHERE l.id = $1
`

type GetLinkRow struct {
	ID        pgtype.UUID
	UserID    pgtype.UUID
	Url       string
	Title     pgtype.Text
	CreatedAt pgtype.Timestamptz
	ReadAt    pgtype.Timestamptz
	Favorite  bool
}

func (q *Queries) GetLink(ctx context.Context, id pgtype.UUID) (GetLinkRow, error) {
	row := q.db.QueryRow(ctx, getLink, id)
	var i GetLinkRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.CreatedAt,
		&i.ReadAt,
		&i.Favorite,
	)
	return i, err
}

const listLinks = `-- name: ListLinks :many
SELECT l.id,
       l.user_id,
       l.url,
       l.title,
       l.created_at,
       l.read_at,
       l.favorite,
       COALESCE(a.extracted_text, '') AS extracted_text
FROM links l
LEFT JOIN archives a ON a.link_id = l.id
WHERE l.user_id = $1
  AND (
    $2 IS NULL OR l.favorite = $2
  )
  AND (
    $3 IS NULL
    OR l.search_tsv @@ plainto_tsquery('english', $3)
    OR l.url ILIKE '%' || $3 || '%'
  )
ORDER BY l.created_at DESC
LIMIT $5
OFFSET $4
`

type ListLinksParams struct {
	UserID   pgtype.UUID
	Favorite interface{}
	Query    interface{}
	Offset   int32
	Limit    int32
}

type ListLinksRow struct {
	ID            pgtype.UUID
	UserID        pgtype.UUID
	Url           string
	Title         pgtype.Text
	CreatedAt     pgtype.Timestamptz
	ReadAt        pgtype.Timestamptz
	Favorite      bool
	ExtractedText string
}

func (q *Queries) ListLinks(ctx context.Context, arg ListLinksParams) ([]ListLinksRow, error) {
	rows, err := q.db.Query(ctx, listLinks,
		arg.UserID,
		arg.Favorite,
		arg.Query,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLinksRow
	for rows.Next() {
		var i ListLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Title,
			&i.CreatedAt,
			&i.ReadAt,
			&i.Favorite,
			&i.ExtractedText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLinkTitle = `-- name: UpdateLinkTitle :exec
UPDATE links
SET title = $1
WHERE id = $2
`

type UpdateLinkTitleParams struct {
	Title pgtype.Text
	ID    pgtype.UUID
}

func (q *Queries) UpdateLinkTitle(ctx context.Context, arg UpdateLinkTitleParams) error {
	_, err := q.db.Exec(ctx, updateLinkTitle, arg.Title, arg.ID)
	return err
}

const upsertArchive = `-- name: UpsertArchive :exec
INSERT INTO archives (
    link_id,
    html,
    extracted_text,
    word_count,
    lang
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
ON CONFLICT (link_id) DO UPDATE
SET html = EXCLUDED.html,
    extracted_text = EXCLUDED.extracted_text,
    word_count = EXCLUDED.word_count,
    lang = EXCLUDED.lang
`

type UpsertArchiveParams struct {
	LinkID        pgtype.UUID
	Html          pgtype.Text
	ExtractedText pgtype.Text
	WordCount     pgtype.Int4
	Lang          pgtype.Text
}

func (q *Queries) UpsertArchive(ctx context.Context, arg UpsertArchiveParams) error {
	_, err := q.db.Exec(ctx, upsertArchive,
		arg.LinkID,
		arg.Html,
		arg.ExtractedText,
		arg.WordCount,
		arg.Lang,
	)
	return err
}
